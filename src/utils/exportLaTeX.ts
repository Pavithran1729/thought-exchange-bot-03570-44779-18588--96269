import { saveAs } from 'file-saver';
import { sanitizeFilename } from './exportHelpers';
import type { AcademicReportConfig } from '@/types/academicReport';
import type { ExtractedData } from './regexProcessor';

// Convert markdown to LaTeX
const markdownToLaTeX = (content: string): string => {
  let latex = content;

  // Escape special LaTeX characters (except in math mode)
  const escapeOutsideMath = (text: string): string => {
    // Split by math delimiters and only escape non-math parts
    const parts = text.split(/(\$\$[\s\S]*?\$\$|\$[^$]+\$|\\\[[\s\S]*?\\\]|\\\(.*?\\\))/);
    return parts.map((part, index) => {
      // Odd indices are math content, keep as-is
      if (index % 2 === 1) return part;
      // Escape special chars in non-math content
      return part
        .replace(/\\/g, '\\textbackslash{}')
        .replace(/&/g, '\\&')
        .replace(/%/g, '\\%')
        .replace(/\$/g, '\\$')
        .replace(/#/g, '\\#')
        .replace(/_/g, '\\_')
        .replace(/\{/g, '\\{')
        .replace(/\}/g, '\\}')
        .replace(/~/g, '\\textasciitilde{}')
        .replace(/\^/g, '\\textasciicircum{}');
    }).join('');
  };

  // Convert math delimiters
  // Display math: $$ ... $$ -> \[ ... \]
  latex = latex.replace(/\$\$([\s\S]*?)\$\$/g, '\\[$1\\]');
  
  // Inline math: $ ... $ -> \( ... \)
  latex = latex.replace(/\$([^$]+)\$/g, '\\($1\\)');

  // Convert headers
  latex = latex.replace(/^######\s+(.+)$/gm, '\\subparagraph{$1}');
  latex = latex.replace(/^#####\s+(.+)$/gm, '\\paragraph{$1}');
  latex = latex.replace(/^####\s+(.+)$/gm, '\\subsubsection{$1}');
  latex = latex.replace(/^###\s+(.+)$/gm, '\\subsection{$1}');
  latex = latex.replace(/^##\s+(.+)$/gm, '\\section{$1}');
  latex = latex.replace(/^#\s+(.+)$/gm, '\\chapter{$1}');

  // Convert bold and italic
  latex = latex.replace(/\*\*\*(.+?)\*\*\*/g, '\\textbf{\\textit{$1}}');
  latex = latex.replace(/\*\*(.+?)\*\*/g, '\\textbf{$1}');
  latex = latex.replace(/\*(.+?)\*/g, '\\textit{$1}');
  latex = latex.replace(/_(.+?)_/g, '\\textit{$1}');

  // Convert strikethrough
  latex = latex.replace(/~~(.+?)~~/g, '\\sout{$1}');

  // Convert code blocks
  latex = latex.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => {
    const language = lang || 'text';
    return `\\begin{lstlisting}[language=${language}]\n${code}\\end{lstlisting}`;
  });

  // Convert inline code
  latex = latex.replace(/`([^`]+)`/g, '\\texttt{$1}');

  // Convert unordered lists
  latex = latex.replace(/^(\s*)-\s+(.+)$/gm, (_, indent, item) => {
    const level = Math.floor(indent.length / 2);
    return `${'  '.repeat(level)}\\item ${item}`;
  });

  // Wrap consecutive list items in itemize environment
  latex = latex.replace(/((?:^\s*\\item .+\n?)+)/gm, (match) => {
    return `\\begin{itemize}\n${match}\\end{itemize}\n`;
  });

  // Convert ordered lists
  latex = latex.replace(/^(\s*)\d+\.\s+(.+)$/gm, (_, indent, item) => {
    return `${indent}\\item ${item}`;
  });

  // Convert blockquotes
  latex = latex.replace(/^>\s+(.+)$/gm, '\\begin{quote}\n$1\n\\end{quote}');

  // Convert horizontal rules
  latex = latex.replace(/^---+$/gm, '\\hrulefill');

  // Convert links
  latex = latex.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '\\href{$2}{$1}');

  // Convert images
  latex = latex.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_, alt, src) => {
    return `\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{${src}}\n\\caption{${alt}}\n\\end{figure}`;
  });

  // Convert tables
  latex = latex.replace(/^\|(.+)\|$/gm, (match) => {
    const cells = match.split('|').filter(c => c.trim()).map(c => c.trim());
    if (cells.every(c => /^[-:]+$/.test(c))) {
      return '\\hline';
    }
    return cells.join(' & ') + ' \\\\';
  });

  // Clean up multiple newlines
  latex = latex.replace(/\n{3,}/g, '\n\n');

  return latex;
};

// Generate LaTeX document
export const generateLaTeXDocument = (
  title: string,
  content: string,
  config: AcademicReportConfig,
  extractedData: ExtractedData[] = []
): string => {
  const { academicDetails, structure, reportType } = config;

  // Determine document class based on report type
  const documentClass = reportType === 'thesis' ? 'report' : 'article';
  
  // Convert content to LaTeX
  const latexContent = markdownToLaTeX(content);

  // Build the LaTeX document
  const document = `% ${title}
% Generated by Academic Report Generator
% Date: ${new Date().toLocaleDateString()}

\\documentclass[12pt,a4paper]{${documentClass}}

% ============ Packages ============
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{times}
\\usepackage[margin=2.5cm]{geometry}
\\usepackage{setspace}
\\usepackage{graphicx}
\\usepackage{float}
\\usepackage{booktabs}
\\usepackage{longtable}
\\usepackage{array}
\\usepackage{hyperref}
\\usepackage{xcolor}
\\usepackage{listings}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{amsthm}
\\usepackage{mathtools}
\\usepackage{fancyhdr}
\\usepackage{titlesec}
\\usepackage[normalem]{ulem}
\\usepackage{caption}
\\usepackage{subcaption}
${structure.includeToc ? '\\usepackage{tocloft}' : ''}
${structure.includeReferences ? '\\usepackage[backend=biber,style=' + getCitationStylePackage(structure.citationStyle) + ']{biblatex}' : ''}

% ============ Configuration ============
\\onehalfspacing
\\setlength{\\parindent}{0pt}
\\setlength{\\parskip}{1em}

% Hyperref setup
\\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={${escapeLatex(title)}},
    pdfauthor={${escapeLatex(academicDetails.authorName)}},
}

% Code listing style
\\lstset{
    basicstyle=\\ttfamily\\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\\tiny\\color{gray},
    keywordstyle=\\color{blue},
    commentstyle=\\color{green!60!black},
    stringstyle=\\color{orange},
    showstringspaces=false,
    tabsize=2,
}

% Header and footer
\\pagestyle{fancy}
\\fancyhf{}
\\fancyhead[L]{\\leftmark}
\\fancyhead[R]{${escapeLatex(academicDetails.institution)}}
\\fancyfoot[C]{\\thepage}
\\renewcommand{\\headrulewidth}{0.4pt}
\\renewcommand{\\footrulewidth}{0.4pt}

% ============ Document ============
\\begin{document}

${structure.includeCoverPage ? generateCoverPage(title, academicDetails, reportType) : ''}

${structure.includeToc ? `
% Table of Contents
\\tableofcontents
\\newpage
` : ''}

${structure.includeAbstract ? `
% Abstract
\\begin{abstract}
[Abstract content will be placed here. Replace this placeholder with your abstract.]
\\end{abstract}
\\newpage
` : ''}

% Main Content
${latexContent}

${structure.includeReferences ? `
% References
\\newpage
\\printbibliography[title={References}]
` : ''}

\\end{document}
`;

  return document;
};

// Generate cover page
const generateCoverPage = (
  title: string,
  details: AcademicReportConfig['academicDetails'],
  reportType: string
): string => {
  const reportTypeLabel = getReportTypeLabel(reportType);
  
  return `
% Cover Page
\\begin{titlepage}
\\centering

\\vspace*{1cm}

{\\Large\\textbf{${escapeLatex(details.institution)}}}

\\vspace{0.5cm}

${details.department ? `{\\large ${escapeLatex(details.department)}}\\\\[0.3cm]` : ''}
${details.course ? `{\\large ${escapeLatex(details.course)}}\\\\` : ''}

\\vspace{2cm}

{\\Huge\\textbf{${escapeLatex(title)}}}

\\vspace{1.5cm}

{\\Large\\textit{${reportTypeLabel}}}

\\vspace{2cm}

\\begin{tabular}{rl}
\\textbf{Author:} & ${escapeLatex(details.authorName)} \\\\
${details.studentId ? `\\textbf{Student ID:} & ${escapeLatex(details.studentId)} \\\\` : ''}
${details.supervisorName ? `\\textbf{Supervisor:} & ${escapeLatex(details.supervisorName)} \\\\` : ''}
\\textbf{Date:} & ${formatDate(details.submissionDate)} \\\\
\\end{tabular}

\\vfill

\\end{titlepage}
\\newpage
`;
};

// Helper functions
const escapeLatex = (text: string): string => {
  if (!text) return '';
  return text
    .replace(/\\/g, '\\textbackslash{}')
    .replace(/&/g, '\\&')
    .replace(/%/g, '\\%')
    .replace(/\$/g, '\\$')
    .replace(/#/g, '\\#')
    .replace(/_/g, '\\_')
    .replace(/\{/g, '\\{')
    .replace(/\}/g, '\\}')
    .replace(/~/g, '\\textasciitilde{}')
    .replace(/\^/g, '\\textasciicircum{}');
};

const getCitationStylePackage = (style: string): string => {
  const styles: Record<string, string> = {
    'apa': 'apa',
    'ieee': 'ieee',
    'harvard': 'authoryear',
    'mla': 'mla',
    'chicago': 'chicago-authordate',
  };
  return styles[style] || 'numeric';
};

const getReportTypeLabel = (type: string): string => {
  const labels: Record<string, string> = {
    'research-paper': 'Research Paper',
    'project-report': 'Project Report',
    'thesis': 'Thesis/Dissertation',
    'lab-report': 'Laboratory Report',
    'case-study': 'Case Study',
    'literature-review': 'Literature Review',
  };
  return labels[type] || 'Academic Report';
};

const formatDate = (dateString: string): string => {
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
  } catch {
    return dateString;
  }
};

// Export function
export const exportToLaTeX = async (
  title: string,
  content: string,
  config: AcademicReportConfig,
  extractedData: ExtractedData[] = []
): Promise<void> => {
  const latexDocument = generateLaTeXDocument(title, content, config, extractedData);
  const filename = `${sanitizeFilename(title)}_Academic.tex`;
  
  const blob = new Blob([latexDocument], { type: 'text/x-latex;charset=utf-8' });
  saveAs(blob, filename);
};
